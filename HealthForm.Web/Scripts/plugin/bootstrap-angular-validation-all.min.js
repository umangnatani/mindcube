'use strict';

angular.module('bootstrap.angular.validation', []);


angular.module('bootstrap.angular.validation').provider('bsValidationConfig', function () {

    // Can be a string or list of any combination of "blur", "submit" & "display"
    var validateFieldsOn = 'blur';
    // Display the validation error message below the `input` field with class "help-block"
    var displayErrorsAs = 'simple';

    function shouldValidateOn(event) {
        if (angular.isString(validateFieldsOn)) {
            return validateFieldsOn === event;
        }

        return validateFieldsOn.indexOf(event) !== -1;
    }

    var _this = this;
    this.global = {};
    this.global.addSuccessClass = true;
    this.global.errorClass = 'has-error';
    this.global.successClass = 'has-success';
    this.global.errorMessagePrefix = '';
    this.global.tooltipPlacement = 'bottom-left';
    this.global.tooltipAppendToBody = false;

    this.global.messages = {
        required: 'This field is required.',
        email: 'Please enter a valid email address.',
        strictemail: 'Please enter a valid email address.',
        url: 'Please enter a valid URL.',
        number: 'Please enter a valid number.',
        digits: 'Please enter only digits.',
        min: 'Please enter a value greater than or equal to {{validValue}}.',
        max: 'Please enter a value less than or equal to {{validValue}}.',
        length: 'Please enter all {{validValue}} characters.',
        minlength: 'Please enter at least {{validValue}} characters.',
        maxlength: 'Please enter no more than {{validValue}} characters.',
        editable: 'Please select a value from dropdown.',
        pattern: 'Please fix the pattern.',
        equalto: 'Please enter the same {{matchName}} again.'
    };

    this.global.setValidateFieldsOn = function (event) {
        if (!event) {
            throw 'Please provide an string or list of events to validate fields on';
        }

        if (!angular.isString(event) && !angular.isArray(event)) {
            throw 'Event should either be a string or a list';
        }

        validateFieldsOn = event;
    };

    this.global.setDisplayErrorsAs = function (type) {
        if (!type) {
            throw 'Please provide the way validation error should be displayed. In-built options are "simple" & "tooltip".';
        }

        displayErrorsAs = type;
    };

    this.$get = [function () {
        return {
            messages: _this.global.messages,
            errorClass: _this.global.errorClass,
            successClass: _this.global.successClass,
            tooltipAppendToBody: _this.global.tooltipAppendToBody,

            getDisplayErrorsAs: function () {
                return displayErrorsAs;
            },

            getErrorMessagePrefix: function () {
                return _this.global.errorMessagePrefix || '';
            },

            getTooltipPlacement: function () {
                return _this.global.tooltipPlacement;
            },

            shouldAddSuccessClass: function () {
                return _this.global.addSuccessClass;
            },

            shouldValidateOn: shouldValidateOn
        };
    }];
});

if (!window.jQuery) {
    /**
     * @ngdoc function
     * @name angular.element.prototype.find
     * @param {String} selector name.
     * @description Mimic jQuery find method. Returns the elements within the document that matches the specified
     * group of selectors. This methods are injected to angular.element() instances. Used when jQuery is not available.
     */
    angular.element.prototype.find = function (selector) {
        return angular.element(this[0].querySelectorAll(selector));
    };
}

if (!window.jQuery && !angular.element.prototype.parents) {
    /**
     * @ngdoc function
     * @name angular.element.prototype.parents
     * @param {String} selector name (optional).
     * @description Mimic jQuery parents method.
     * Get the ancestors of each element in the current set of matched elements, optionally filtered by a selector.
     * This methods are injected to angular.element() instances. Used when jQuery is not available.
     */
    angular.element.prototype.parents = function (selector) {
        // At least IE6
        var isIE = /*@cc_on!@*/false || !!document.documentMode;

        var element = this[0];
        var parents = [];

        // Traverse element's ancestor tree until the upto the root and pushing all the ancestors to an array.
        while (element.parentNode.parentNode) {
            element = element.parentNode;

            // Get the ancestors of element filtered by a selector (if any)
            if (selector) {
                if (isIE) {
                    /*
                     * For IE versions less then 9. Since Microsoft introduces msMatchesSelector method from 9.
                     * @see Browser compatibility in https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
                     */
                    if (element.msMatchesSelector(selector)) {
                        parents.push(element);
                    }
                } else {
                    if (element.matches(selector)) {
                        parents.push(element);
                    }
                }
            } else {
                // If no selector is defined then get all the ancestors with no filtering
                parents.push(element);
            }
        }
        return angular.element(parents);
    };
}

if (!String.prototype.camelCaseToDash) {
    String.prototype.camelCaseToDash = function () {
        return this.replace(/([A-Z])/g, function ($1) {
            return '-' + $1.toLowerCase();
        });
    };
}

/**
 * @ngcode service
 * @name BsValidationService
 * @description Core service of this module to provide various default validations.
 */
angular.module('bootstrap.angular.validation').factory('BsValidationService', ['$interpolate', 'bsValidationConfig',
'$injector', function ($interpolate, validationConfig, $injector) {

    var displayErrorAsAttrName = 'bsDisplayErrorAs';
    var customFormGroup = '[bs-form-group]';
    var formGroupClass = '.form-group';

    var genericValidators = {
        digits: function (value) {
            return (/^\d+$/).test(value);
        },
        equalto: function (value, $scope, attr) {
            return value + '' === $scope.$eval(attr.equalto) + '';
        },
        number: function (value) {
            return (/^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/).test(value);
        },
        min: function (value, $scope, attr) {
            return parseFloat(value) >= parseFloat(attr.min);
        },
        max: function (value, $scope, attr) {
            return parseFloat(value) <= parseFloat(attr.max);
        },
        length: function (value, $scope, attr) {
            return value.length === parseInt(attr.length);
        },
        strictemail: function (value) {
            return new RegExp(/^[_a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$/).test(value);
        }
    };

    function getTrigger($element, triggerEvent) {
        var attributeName = 'bs-trigger';
        if ($element.attr(attributeName)) {
            return $element.attr(attributeName) === triggerEvent;
        }

        var parentForm = $element.parents('form');
        if (parentForm && parentForm.attr(attributeName)) {
            return parentForm.attr(attributeName) === triggerEvent;
        }

        // Use the global config
        return validationConfig.shouldValidateOn(triggerEvent);
    }

    var meta = ['matchName'];

    return {
        /**
         * Search all the input element inside the given DOM element and apply the 'bs-validation' directive so we
         * need not a add it for every form element.
         */
        getValidators: function () {
            var builtIn = ['equalto', 'min', 'max', 'number', 'digits', 'length'];
            var additional = Object.keys(genericValidators);
            return builtIn.concat(additional);
        },

        getMetaInformation: function ($element) {
            var metaInformation = {};

            angular.forEach(meta, function (key) {
                metaInformation[key] = $element.attr(key) || $element.attr(key.camelCaseToDash());
            });

            return metaInformation;
        },

        addErrorClass: function ($formGroupElement) {
            this.removeErrorClass($formGroupElement);
            $formGroupElement.addClass(validationConfig.errorClass);
        },

        addSuccessClass: function ($formGroupElement) {
            this.removeErrorClass($formGroupElement);

            if (validationConfig.shouldAddSuccessClass()) {
                $formGroupElement.addClass(validationConfig.successClass);
            }
        },

        addValidator: function ($scope, $attr, ngModelController, validatorKey) {
            ngModelController.$validators[validatorKey] = function (modelValue, viewValue) {
                var value = modelValue || viewValue;
                return ngModelController.$isEmpty(value) || genericValidators[validatorKey](value, $scope, $attr);
            };
        },

        displayErrorPreference: function ($element, $attr) {
            var attrName = displayErrorAsAttrName;
            if ($attr[attrName]) {
                return $attr[attrName];
            } else {
                var $parentForm = $element.parents('form');

                // .attr() method not accepting camelCase version of the attribute name. Converting it to dashed-case
                attrName = attrName.camelCaseToDash();

                if ($parentForm && $parentForm.attr(attrName)) {
                    return $parentForm.attr(attrName);
                }
            }

            // Use the global preference
            return validationConfig.getDisplayErrorsAs();
        },

        getErrorMessage: function ($element, $attr, ngModelController) {
            var firstErrorKey = Object.keys(ngModelController.$error)[0];
            return validationConfig.getErrorMessagePrefix() + this.resolveMessage($element, $attr, firstErrorKey);
        },

        getFormGroupElement: function ($element) {
            // Search parent element with class form-group to operate on.
            var formGroupElement = $element.parents(formGroupClass);

            // Search for an attribute 'bs-form-group' if the class '.form-group' is not available
            if (!formGroupElement || formGroupElement.length === 0) {
                formGroupElement = $element.parents(customFormGroup);

                if (!formGroupElement || formGroupElement.length === 0) {
                    return null;
                }
            }

            return formGroupElement;
        },

        getValidationMessageService: function (displayType) {
            var validationMessageService;

            try {
                validationMessageService = $injector.get(displayType + 'MessageService');
            } catch (e) {
                throw 'No message service found for type [' + displayType + '].';
            }

            if (displayType === 'tooltip' && !$injector.has('$uibPosition')) {
                throw '$uibPosition service required from the ui-bootstrap module in order to use the tooltip message.';
            }

            return validationMessageService;
        },

        isValidationDisabled: function ($element) {
            var attribute = 'bs-no-validation';
            if ($element[0].attributes.hasOwnProperty(attribute)) {
                return true;
            }

            var $parentForm = $element.parents('form');
            return $parentForm[0] && $parentForm[0].attributes.hasOwnProperty(attribute);
        },

        removeErrorClass: function ($formGroupElement) {
            $formGroupElement.removeClass(validationConfig.errorClass);
        },

        removeSuccessClass: function ($formGroupElement) {
            $formGroupElement.removeClass(validationConfig.successClass);
        },

        resolveMessage: function ($element, $attr, key) {
            var metaInformation = this.getMetaInformation($element);
            var message = $element.attr(key + '-notification') || validationConfig.messages[key];

            if (!message) {
                console.warn('No message found for the key [' + key + ']. Consider adding a global message or element' +
                  ' specific message using attribute [' + key + '-notification="My custom message"]');

                message = 'Please fix this field';
            }

            var matchers = angular.extend({}, { validValue: $attr[key] }, metaInformation);
            return $interpolate(message)(matchers);
        },

        shouldValidateOnBlur: function ($element) {
            return getTrigger($element, 'blur');
        },

        shouldValidateOnDisplay: function ($element) {
            return getTrigger($element, 'display');
        },

        shouldValidateOnSubmit: function ($element) {
            return getTrigger($element, 'submit');
        }

    };
}]);

angular.module('bootstrap.angular.validation').factory('simpleMessageService', ['BsValidationService', function (validationService) {

    var errorElementClass = '.bs-invalid-msg';

    function getErrorContainer($element, $formGroupElement) {
        var $errorElement = $formGroupElement.find(errorElementClass);
        if ($errorElement && $errorElement.length) {
            return $errorElement;
        }

        var insertAfter;

        // Check if the container have any Bootstrap input group then append the error after it
        var groupElement = $formGroupElement.find('.input-group');
        if (groupElement.length > 0) {
            insertAfter = groupElement;
        } else {
            insertAfter = $element;
        }

        insertAfter.after('<span class="help-block ' + errorElementClass.substring(1) + '"></span>');
        return $formGroupElement.find(errorElementClass);
    }

    return {
        destroyMessage: function () {
            // Need not to do anything. Error elements will be automcatically removed on DOM unload
        },

        hideErrorMessage: function ($element, $formGroupElement) {
            validationService.removeErrorClass($formGroupElement);
            $formGroupElement.find(errorElementClass).addClass('ng-hide');
        },

        showErrorMessage: function ($element, $attr, ngModelController, $formGroupElement) {
            var message = validationService.getErrorMessage($element, $attr, ngModelController);

            var $errorElement = getErrorContainer($element, $formGroupElement);
            $errorElement.html(message).removeClass('ng-hide');
        }
    };
}]);

angular.module('bootstrap.angular.validation').factory('tooltipMessageService', ['$injector', 'BsValidationService',
'$interpolate', '$templateCache', 'bsValidationConfig',
function ($injector, validationService, $interpolate, $templateCache, validationConfig) {

    function getElementID($element) {
        var id = $element.attr('id');
        if (id) {
            return id;
        }

        id = 'bs-' + (Math.floor(Math.random() * 10000)) + '-' + Math.floor(Math.random() * 10000);
        $element.attr('id', id);
        return id;
    }

    function getErrorTooltip($element) {
        var tooltipID = 'bs-error-' + getElementID($element);
        var tooltipElement = document.getElementById(tooltipID);

        if (tooltipElement) {
            return angular.element(tooltipElement);
        }

        var data = { errorClass: validationConfig.errorClass, tooltipID: tooltipID };
        var html = $templateCache.get('bav/template/tooltip.html');
        html = $interpolate(html)(data);

        if (validationConfig.tooltipAppendToBody) {
            angular.element(document.body).append(html);
        } else {
            $element.after(html);
        }

        return angular.element(document.getElementById(tooltipID));
    }

    function getTooltipPlacement($element) {
        var attributeName = 'bs-tooltip-placement';
        if ($element.attr(attributeName)) {
            return $element.attr(attributeName);
        }

        var parentForm = $element.parents('form');
        if (parentForm && parentForm.attr(attributeName)) {
            return parentForm.attr(attributeName);
        }

        // Use the global config
        return validationConfig.getTooltipPlacement();
    }

    return {
        destroyMessage: function ($element) {
            if (validationConfig.tooltipAppendToBody) {
                // If tooltip messages were appended to body then remove them
                getErrorTooltip($element).remove();
            }
        },

        hideErrorMessage: function ($element, $formGroupElement) {
            validationService.removeErrorClass($formGroupElement);
            getErrorTooltip($element).removeClass('in');
        },

        showErrorMessage: function ($element, $attr, ngModelController) {
            var message = validationService.getErrorMessage($element, $attr, ngModelController);
            var $errorTooltip = getErrorTooltip($element);
            var placement = getTooltipPlacement($element);
            var appendToBody = validationConfig.tooltipAppendToBody;

            $errorTooltip.find('.tooltip-inner').html(message);

            var $position = $injector.get('$uibPosition');
            var ttPosition = $position.positionElements($element, $errorTooltip, placement, appendToBody);
            $errorTooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });
            $errorTooltip.addClass('in');

            if (ttPosition.placement && !$errorTooltip.hasClass(ttPosition.placement.split('-')[0])) {
                $errorTooltip.addClass(ttPosition.placement.split('-')[0]);
            }

            $position.positionArrow($errorTooltip, ttPosition.placement);
        }
    };
}]);

angular.module('bootstrap.angular.validation').run(['$templateCache', function ($templateCache) {
    $templateCache.put('bav/template/tooltip.html', '<div class="tooltip {{errorClass}}" id="{{tooltipID}}"' +
      ' role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>');
}]);

/**
 * @ngdoc directive
 * @name form
 * @description Using "form" element as directive so we don't require to put the "bs-validation" directive to every form
 * element.
 */
angular.module('bootstrap.angular.validation').directive('form', [
  '$parse',
  function ($parse) {
      return {
          restrict: 'E',
          require: 'form',
          priority: 1000,     // Setting a higher priority so that this directive compiles first.
          compile: function ($formElement, $formAttributes) {
              // Disable HTML5 validation display
              $formElement.attr('novalidate', 'novalidate');

              var ngSubmit = $formAttributes.ngSubmit;
              /*
               * Removing ngSubmit attribute if any since ngSubmit by default doesn't respects the validation errors
               * on the input fields.
               */
              delete $formAttributes.ngSubmit;

              var preLinkFunction = function ($scope, formElement, $attr, formController) {
                  // Expose a method to manually show the validation state
                  formController.$showValidation = function () {
                      formController.$setSubmitted();
                      // Tell form elements to show validation state
                      $scope.$broadcast('onBsValidationStateChange', { showValidationState: true });
                  };

                  formController.$hideValidation = function () {
                      formController.$setPristine();
                      // Tell form elements to hide validation state
                      $scope.$broadcast('onBsValidationStateChange', { showValidationState: false });
                  };

                  formElement.on('submit', function (e) {
                      e.preventDefault();

                      // If any of the form element has not passed the validation
                      if (formController.$invalid) {
                          // Then focus the first invalid element
                          formElement[0].querySelector('.ng-invalid').focus();
                          return false;
                      }

                      // Parse the handler of ng-submit & execute it
                      var submitHandler = $parse(ngSubmit);
                      $scope.$apply(function () {
                          submitHandler($scope, { $event: e });

                          formController.$commitViewValue();
                          formController.$setSubmitted();

                          /*
                           * Do not show validation errors once the form gets submitted. You can still display the
                           * validation errors after form submission by calling '$setSubmitted' in your form controller.
                           */
                          formController.$hideValidation();
                      });

                      /**
                       * Prevent other submit event listener registered via Angular so that we can mark the form with
                       * the pristine state. Otherwise, that Angular's listener is getting called at the last and is again
                       * setting form to the submitted.
                       *
                       * https://api.jquery.com/event.stopimmediatepropagation/
                       */
                      e.stopImmediatePropagation();
                      return false;
                  });
              };

              return {
                  pre: preLinkFunction
              };
          }
      };
  }]);

(function () {
    var directiveFunction = ['bsValidationDirective', 'BsValidationService', function (bsValidationDirective, validationService) {

        return {
            restrict: 'E',
            require: bsValidationDirective[0].require,
            compile: function ($element, $attr) {
                // Do not add validation directive if an attribute "bs-no-validation" is present
                if (validationService.isValidationDisabled($element)) {
                    return;
                }

                // Do not add validation directive if the directive "ng-model" is not present
                if (!$attr.hasOwnProperty('ngModel')) {
                    return;
                }

                // Do not add validation directive if the directive is already present
                if ($attr.hasOwnProperty('bsValidation')) {
                    return;
                }

                // Add the validation directive
                $element.attr('bs-validation', '');

                // Return the linking function of the "bsValidation" directive from here so that we don't have to duplicate it
                return bsValidationDirective[0].link;
            }
        };
    }];

    /**
     * @ngdoc directive
     * @name input, select, textarea
     * @description There are situations where we add some form elements dynamically either using some directive or
     * using "ng-include" then the validation directive won't work automatically and we have to manually add the
     * "bs-validation" directive manually on them.
     *
     * Adding below these directive will fix the above stated problem.
     */
    angular.module('bootstrap.angular.validation')
      .directive('input', directiveFunction)
      .directive('select', directiveFunction)
      .directive('textarea', directiveFunction);
})();

/**
 * @ngdoc directive
 * @name bsValidation
 * @requires BsValidationService
*/
angular.module('bootstrap.angular.validation').directive('bsValidation', [
  '$timeout', '$injector', 'BsValidationService',
    function ($timeout, $injector, validationService) {
        return {
            restrict: 'A',
            require: ['?ngModel', '?^^form'],
            link: function ($scope, $element, $attr, controllers) {
                if (validationService.isValidationDisabled($element)) {
                    return;
                }

                // Initialize controllers
                var ngModelController = controllers[0];
                var ngFormController = controllers[1];

                if (!ngModelController) {
                    throw 'ng-model directive is required for the bs-validation directive to work.';
                }

                var $formGroupElement = validationService.getFormGroupElement($element);
                if (!$formGroupElement) {
                    throw 'No parent form group element found for input element';
                }

                var displayValidationState = false;
                var shouldValidateOnBlur = validationService.shouldValidateOnBlur($element);
                var shouldValidateOnDisplay = validationService.shouldValidateOnDisplay($element);
                var shouldValidateOnSubmit = validationService.shouldValidateOnSubmit($element);

                var displayErrorAs = validationService.displayErrorPreference($element, $attr);
                var validationMessageService = validationService.getValidationMessageService(displayErrorAs);

                // Register generic custom validators if added to element
                angular.forEach(validationService.getValidators(), function (key) {
                    var attrValue = $element.attr(key);
                    if ($attr[key] || (angular.isDefined(attrValue) && attrValue !== false)) {
                        validationService.addValidator($scope, $attr, ngModelController, key);
                    }
                });

                function addErrorClass() {
                    validationService.addErrorClass($formGroupElement);
                }

                function removeSuccessClass() {
                    validationService.removeSuccessClass($formGroupElement);
                }

                function displayError() {
                    addErrorClass();
                    validationMessageService.showErrorMessage($element, $attr, ngModelController, $formGroupElement);
                }

                function hideError() {
                    validationMessageService.hideErrorMessage($element, $formGroupElement);
                }

                function addSuccessClass() {
                    validationService.addSuccessClass($formGroupElement);
                    return hideError();
                }

                function displaySuccess() {
                    addSuccessClass();
                }

                function hideSuccess() {
                    removeSuccessClass();
                }

                function displayOrHideValidationState() {
                    if (!displayValidationState) {
                        hideSuccess();
                        return hideError();
                    }

                    if (ngModelController.$valid) { return displaySuccess(); }
                    if (ngModelController.$invalid) { return displayError(); }
                }

                function showValidation() {
                    displayValidationState = true;
                    displayOrHideValidationState();
                }

                function hideValidation() {
                    displayValidationState = false;
                    displayOrHideValidationState();
                }

                if (shouldValidateOnBlur) {
                    var dewatcher = $scope.$watch(function () {
                        return ngModelController.$touched;
                    }, function (lostFocus) {
                        if (lostFocus) {
                            displayValidationState = true;
                            displayOrHideValidationState();
                            dewatcher();
                        }
                    });
                }

                if (shouldValidateOnSubmit && ngFormController) {
                    // register watchers for submission touch and valid
                    $scope.$watch(function () {
                        return ngFormController.$submitted;
                    }, function (submitted) {
                        displayValidationState = submitted;
                        displayOrHideValidationState();
                    });
                }

                if (shouldValidateOnDisplay) {
                    showValidation();
                }

                // TODO Find alternative for this watch
                $scope.$watch(function () {
                    return ngModelController.$error;
                }, displayOrHideValidationState, true);

                $scope.$on('onBsValidationStateChange', function (e, data) {
                    displayValidationState = data.showValidationState;
                    displayOrHideValidationState();
                });

                $scope.$on('$destroy', function () {
                    validationMessageService.destroyMessage($element);
                });

                ngModelController.$showValidation = showValidation;
                ngModelController.$hideValidation = hideValidation;
            }
        };
    }
]);